---
# SPDX-FileCopyrightText: the secureCodeBox authors
#
# SPDX-License-Identifier: Apache-2.0

title: "ADR-0020: Adopting Common Expression Language (CEL) for CascadingRule Matching"
sidebar_label: "ADR-0020"
---
# ADR-0020: Adopting Common Expression Language (CEL) for CascadingRule Matching

| <!-- -->       | <!-- -->                                                                                     |
|----------------|----------------------------------------------------------------------------------------------|
| **Status**:    | PROPOSED                                                                                     |
| **Date**:      | 2025-10-14                                                                                   |
| **Author(s)**: | Jannik Hollenbach [jannik.hollenbach@iteratec.com](mailto:jannik.hollenbach@iteratec.com)    |

## Context

CascadingRules in secureCodeBox currently use a custom `matches` object syntax to define which findings should trigger subsequent scans. The current implementation uses a declarative YAML structure with `anyOf` rules that perform partial deep comparison against finding fields:

```yaml
spec:
  matches:
    anyOf:
      - category: "Open Port"
        attributes:
          port: 22
          state: open
      - category: "Open Port"
        attributes:
          service: "ssh"
          state: open
```

While this approach works well for simple matching scenarios, it has several limitations:

1. **Limited Expressiveness**: The current syntax only supports exact matching and partial deep comparison. Complex conditions like range checks, regex patterns, logical combinations beyond `anyOf`, or computed values are not possible without extending the custom syntax.
2. **Maintenance Burden**: Every new matching requirement necessitates extending the custom matcher implementation. This creates ongoing maintenance overhead and increases the complexity of the codebase.
3. **Lack of Flexibility**: Common use cases like checking if a port is within a range (e.g., `port >= 8000 && port <= 9000`), matching against multiple patterns, or combining conditions with complex boolean logic require workarounds or are simply not possible.

[Common Expression Language (CEL)](https://github.com/google/cel-spec) is a non-Turing complete expression language designed for evaluating expressions in a safe, fast, and portable manner. It is already widely adopted in the Kubernetes ecosystem, particularly in:

- Kubernetes ValidatingAdmissionPolicy (since v1.26)
- Kubernetes Custom Resource Definitions (CRD validation rules)
- Istio authorization policies
- Various other cloud-native projects

CEL provides a familiar C-like syntax and is specifically designed for configuration and policy evaluation use cases, making it an ideal fit for CascadingRule matching logic.

## Decision

We propose migrating the CascadingRule `matches` specification from the current custom object syntax to use Common Expression Language (CEL) expressions.

### Proposed Syntax

Instead of the current `matches.anyOf` structure, users would write CEL expressions that evaluate to a boolean:

```yaml
spec:
  matches:
    expression: |
      (finding.category == "Open Port" && finding.attributes.port == 22 && finding.attributes.state == "open") ||
      (finding.category == "Open Port" && finding.attributes.service == "ssh" && finding.attributes.state == "open")
```

Or more concisely:

```yaml
spec:
  matches:
    expression: |
      finding.category == "Open Port" && 
      finding.attributes.state == "open" &&
      (finding.attributes.port == 22 || finding.attributes.service == "ssh")
```

### Advanced Use Cases Enabled by CEL

CEL would enable powerful matching scenarios that are currently impossible:

**Range Checks:**
```yaml
expression: |
  finding.category == "Open Port" && 
  finding.attributes.port >= 8000 && 
  finding.attributes.port <= 9000
```

**Regex Matching:**
```yaml
expression: |
  finding.category == "Subdomain" && 
  finding.attributes.hostname.matches("^.*\\.example\\.com$")
```

**Complex Boolean Logic:**
```yaml
expression: |
  (finding.severity in ["HIGH", "CRITICAL"] && finding.category == "Vulnerability") ||
  (finding.category == "Open Port" && finding.attributes.port in [22, 23, 3389])
```

**Computed Values:**
```yaml
expression: |
  finding.category == "Open Port" && 
  has(finding.attributes.service) &&
  finding.attributes.service.startsWith("http")
```

### Migration Strategy

To ensure backward compatibility and smooth migration:

1. **Dual Support Period**: Support both the legacy `matches.anyOf` syntax and the new `matches.expression` syntax simultaneously for at least two major versions.
2. (maybe?) **Automatic Translation**: Provide tooling or documentation to help users translate existing `anyOf` rules to CEL expressions.
3. (consider) **Validation**: Implement comprehensive validation of CEL expressions at CRD admission time to catch syntax errors early. We have avoided validating webhooks so far, as they have a overhead in terms of cert management, but might be worthwhile for this issue.
4. **Documentation**: Create extensive documentation with examples showing common patterns and migration guides.
5. **Proposed Deprecation Path**:
   - Version 5.x: Introduce CEL support alongside existing syntax and mark `anyOf` as deprecated with warnings
   - Version 6.0.0: Remove support for `anyOf` syntax

## Consequences

### Positive Consequences

1. **Increased Flexibility**: Users can express arbitrarily complex matching logic without waiting for custom syntax extensions.
2. **Reduced Maintenance**: The secureCodeBox team no longer needs to maintain and extend custom matching logic. CEL is maintained by Google and the broader community.
3. **Industry Standard**: CEL is becoming the de facto standard for policy expressions in Kubernetes, making it familiar to many users.
4. **Better Tooling**: CEL has existing tooling, documentation, and community support that users can leverage.
5. **Type Safety**: CEL provides compile-time type checking, catching errors before runtime.
6. **Security**: CEL is non-Turing complete and designed to be safe for user-provided expressions, preventing infinite loops or resource exhaustion.

### Negative Consequences

1. **Breaking Change**: Eventually removing the `anyOf` syntax will require users to migrate their existing CascadingRules.
2. **Learning Curve**: Users unfamiliar with CEL will need to learn a new expression syntax, though it's relatively simple and well-documented.
3. **Migration Effort**: Existing CascadingRules will need to be updated, requiring effort from users and clear migration documentation.
4. **Increased Complexity**: The cascading hook codebase will temporarily be more complex during the dual-support period.
5. **Dependency Addition**: Adding the cel library increases the dependency footprint of the operator.
6. **Error Messages**: CEL error messages may be less intuitive than custom validation errors, requiring careful wrapping and contextualization.

## Alternatives Considered

### 1. Extend the Current Custom Syntax

We could continue extending the `matches` object with new fields and operators (e.g., `allOf`, `noneOf`, etc.).

**Rejected because**: This would perpetuate the maintenance burden and still wouldn't provide the full flexibility of a proper expression language. Each new requirement would require code changes and releases.

### 2. Use JSONPath or JMESPath

These are query languages designed for JSON data extraction and filtering.

**Rejected because**: While powerful for data extraction, they are less intuitive for boolean logic and condition evaluation. CEL is specifically designed for policy evaluation use cases.

### 3. Use JavaScript or Lua

Embed a scripting language for maximum flexibility.

**Rejected because**: Full scripting languages are Turing complete and pose security risks when evaluating user-provided code. They also have higher performance overhead and complexity. CEL's non-Turing complete nature makes it safer and more appropriate for this use case.

### 4. Use Rego (Open Policy Agent)

Rego is the policy language used by Open Policy Agent.

**Rejected because**: While Rego is powerful, it has a steeper learning curve and is less widely adopted in the Kubernetes ecosystem compared to CEL. CEL's integration with Kubernetes CRDs and admission policies makes it a more natural fit.

## References

- [CEL Specification](https://github.com/google/cel-spec)
- [cel-go Implementation](https://github.com/google/cel-go)
- [cel-js Implementation](https://github.com/marcbachmann/cel-js)
- [Kubernetes CEL Validation](https://kubernetes.io/docs/reference/using-api/cel/)
- [Current CascadingRule Documentation](https://www.securecodebox.io/docs/api/crds/cascading-rule)